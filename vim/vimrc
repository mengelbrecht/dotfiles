" ------------------------------------------------------------------------------
" vimrc
"
" Inspired by
"     https://github.com/Soliah/dotfiles/blob/master/vimrc
"     https://github.com/wincent/wincent/tree/master/roles/dotfiles/files/.vim
"     https://github.com/junegunn/dotfiles/blob/master/vimrc
"     https://github.com/mhinz/dotfiles/blob/master/vim/vimrc
"     https://github.com/cHoco/dotFiles/blob/master/vimrc
" ------------------------------------------------------------------------------

" ------------------------------------------------------------------------------
" Plugins
" ------------------------------------------------------------------------------
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall | source $MYVIMRC
endif

function! Cond(cond, ...)
  let opts = get(a:000, 0, {})
  return a:cond ? opts : extend(opts, { 'on': [], 'for': [] })
endfunction

call plug#begin()
" Plug 'JazzCore/ctrlp-cmatcher', Cond(!has('nvim'), {'do': './install.sh'}) | Plug 'ctrlpvim/ctrlp.vim', Cond(!has('nvim'))
" Plug 'junegunn/fzf', Cond(has('nvim'), {'do': './install --bin' }) | Plug 'junegunn/fzf.vim', Cond(has('nvim'))
" Plug 'scrooloose/nerdtree', {'on': ['NERDTreeToggle', 'NERDTreeFind']}
" Plug 'tpope/vim-dispatch' | Plug 'mileszs/ack.vim', {'on': 'Ack'}
Plug 'airblade/vim-gitgutter'
Plug 'bling/vim-bufferline'
Plug 'coderifous/textobj-word-column.vim'
Plug 'itchyny/lightline.vim'
Plug 'joshdick/onedark.vim'
Plug 'junegunn/gv.vim', {'on': 'GV'}
Plug 'junegunn/vim-easy-align', {'on': ['<Plug>(LiveEasyAlign)', 'LiveEasyAlign']}
Plug 'justinmk/vim-dirvish'
Plug 'justinmk/vim-sneak'
Plug 'mhinz/vim-grepper', {'on': 'Grepper'}
Plug 'mhinz/vim-sayonara', {'on': 'Sayonara'}
Plug 'mhinz/vim-startify'
Plug 'myint/indent-finder'
Plug 'osyo-manga/vim-over', {'on': 'OverCommandLine'}
Plug 'pgdouyon/vim-evanesco'
Plug 'pgdouyon/vim-niffler', {'on': ['Niffler', 'NifflerBuffer']}
Plug 'rakr/vim-one', {'on': []}
Plug 'rhysd/vim-clang-format', {'on': 'ClangFormat'}
Plug 'scrooloose/syntastic', {'on': 'SyntasticCheck'}
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-eunuch'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-obsession', {'on': 'Obsession'}
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-surround'

" Languages
Plug 'b4winckler/vim-objc', {'for': 'objc'}
Plug 'keith/swift.vim', {'for': 'swift'}
Plug 'kelan/gyp.vim', {'for': 'gyp'}
Plug 'mitsuhiko/vim-python-combined', {'for': 'python'}
Plug 'nickhutchinson/vim-cmake-syntax', {'for': 'cmake'}
Plug 'octol/vim-cpp-enhanced-highlight', {'for': 'cpp'}
Plug 'tbastos/vim-lua', {'for': 'lua'}
Plug 'tpope/vim-git'
Plug 'vim-ruby/vim-ruby', {'for': 'ruby'}
call plug#end()

" ------------------------------------------------------------------------------
" General Settings
" ------------------------------------------------------------------------------
let mapleader                 = "\<SPACE>"
let g:netrw_dirhistmax        = 0 " Disable .netrwhist file creation
" Disable loading of plugins bundled with vim
let g:loaded_2html_plugin     = 1
let g:loaded_getscriptPlugin  = 1
let g:loaded_gzip             = 1
let g:loaded_logipat          = 1
let g:loaded_matchparen       = 1
let g:loaded_netrwPlugin      = 1
let g:loaded_rrhelper         = 1
let g:loaded_spellfile_plugin = 1
let g:loaded_tarPlugin        = 1
let g:loaded_vimballPlugin    = 1
let g:loaded_zipPlugin        = 1

set shell=$SHELL               " Use zsh as shell
set viminfo=/100,:100,'100     " Save command history and search patterns
set autoread                   " Automatically load changes
set undolevels=1000            " Large undo levels
set history=100                " Size of command history
set encoding=utf8              " Always use unicode
set backspace=indent,eol,start " Fix backspace
set nobackup                   " Disable backups
set clipboard=unnamed          " Use the OS clipboard by default
set ttyfast                    " Optimize for fast terminal connections
set lazyredraw                 " Wait to redraw
set ttimeout                   " Timeout on keycodes
set ttimeoutlen=10             " Small timeout to reduce lag when pressing ESC in terminal
set nomodeline                 " Hide modeline
set wildchar=<Tab>             " Complete with Tab
set wildmenu                   " Show list
set wildmode=longest:full,full " Show all matches
set whichwrap+=<,>,h,l,[,]     " Move lines using arrows.
set virtualedit=onemore        " Allow for cursor beyond last character
set switchbuf=usetab           " Switch to the window of the buffer
set incsearch                  " Show partial matches as search is entered.
set hlsearch                   " Highlight search patterns.
set ignorecase                 " Enable case insensitive search.
set smartcase                  " Disable case insensitivity if mixed case.
set wrapscan                   " Wrap to top of buffer when searching.
set gdefault                   " Make search and replace global by default.
set autoindent                 " Keep indentation
set tabstop=4                  " Set tab to equal 4 spaces
set softtabstop=4              " Set soft tabs equal to 4 spaces
set shiftwidth=4               " Set auto indent spacing
set shiftround                 " Shift to the next round tab stop
set expandtab                  " Expand tabs into spaces
set smarttab                   " Insert spaces in front of lines
set list                       " Show whitespace
set listchars=tab:╶─           " Tab symbol
set listchars+=trail:·         " Trailing whitespace
set listchars+=extends:#       " Character to show when wrap is off
set listchars+=nbsp:%          " Non breakable whitespace
set cf                         " Enable error jumping.
set nostartofline              " Do not move cursor to start of line after line-wise command
set gcr=a:blinkon0             " Non blinking cursor
set hidden                     " Allow hidden buffers
set matchpairs+=<:>            " Pairs to match
set nowrap                     " Wrap text
set cursorline                 " Highlight current line
set number                     " Enable line numbers
set ruler                      " Show the cursor position
set shortmess=aIoO             " Show short messages, no intro
set splitbelow                 " Open new splits below
set splitright                 " Open new splits on the right
set foldlevelstart=99          " Open all folds by default
set showtabline=2              " Always show the tabline
set showcmd                    " Show last command
set noshowmode                 " No need to show mode
set showmatch                  " Show matching parenthesis
set synmaxcol=240              " Limit syntax highlighting to 240 colums
set laststatus=2               " Always show status line
set scrolljump=8               " Scroll 8 lines at a time at top/bottom
set scrolloff=3                " Always show one line above and below cursor
set sidescrolloff=5            " Always show 5 columns before and after cursor
set completeopt-=preview       " Disable preview window for YCM
set noerrorbells               " Disable error bells
set vb t_vb=                   " Disable visual bell
set linespace=1                " Use 1 pixel space between lines
set t_Co=256                   " Terminal supports 256 colors
set t_md=                      " Disable bold fonts in terminal
set background=dark            " Use dark colorscheme

if has('termguicolors')
  set termguicolors " Enable 24bit colors in terminal
endif

if has('nvim')
  let $NVIM_TUI_ENABLE_CURSOR_SHAPE = 1
endif

if has('gui_running')
  set guioptions-=m " Disable menu bar
  set guioptions-=T " Disable the toolbar
  set guioptions-=a " Do not auto copy selection to clipboard
  set guioptions-=e " Do not use gui tab apperance
  set guioptions-=r " Do not show scrollbars
  set guioptions-=R " Do not show scrollbars
  set guioptions-=l " Do not show scrollbars
  set guioptions-=L " Do not show scrollbars

  if has('gui_macvim')
    set guifont=PragmataPro\ Mono:h14 " Set font
    set macligatures                  " Enable ligatures
    if &background ==# 'dark'
      set macthinstrokes              " Use thin strokes in dark colorscheme
    endif
  endif
endif

let s:powerline_font              = 1 " Enable for powerline glyphs
if s:powerline_font
  let s:symbol_separator_left     = "\uE0B0"
  let s:symbol_separator_right    = "\uE0B2"
  let s:symbol_subseparator_left  = "\uE0B1"
  let s:symbol_subseparator_right = "\uE0B3"
  let s:symbol_vcs_branch         = "\uE0A0"
else
  let s:symbol_separator_left     = ""
  let s:symbol_separator_right    = ""
  let s:symbol_subseparator_left  = "\u2502"
  let s:symbol_subseparator_right = "\u2502"
  let s:symbol_vcs_branch         = "\u16B4"
endif

" ------------------------------------------------------------------------------
" Keymappings
" ------------------------------------------------------------------------------
" Correct common shift key misspellings
cmap W w
cmap WQ wq
cmap wQ wq
cmap Q q

" Yank from the cursor to the end of the line, to be consistent with C and D.
nnoremap Y y$

" Visual shifting (without exiting visual mode)
vnoremap < <gv
vnoremap > >gv

" Toggle wrapping
map <F2> :set wrap!<CR>

" Invert result highlighting
nnoremap <silent> _ :set invhlsearch<CR>

" Find merge conflict markers
nnoremap <Leader>fc /\v^[<\|=>]{7}( .*\|$)<CR>

" Easier window switching
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Close quickfix and location list
nnoremap <Leader>c :cclose<Bar>lclose<CR>

nnoremap <silent> <C-t> :enew<CR>
nnoremap <silent> <C-x> :Sayonara!<CR>
nnoremap <silent> <C-y> :Sayonara<CR>
nnoremap <silent> <C-u> :bprev<CR>
nnoremap <silent> <C-i> :bnext<CR>

nnoremap <silent> <Leader>t :tabnew<CR>
nnoremap <silent> <Leader>x :tabclose<CR>
nnoremap <silent> <Leader>u :tabprevious<CR>
nnoremap <silent> <Leader>i :tabnext<CR>
noremap <silent> <D-1>      :tabn 1<CR>
noremap <silent> <D-2>      :tabn 2<CR>
noremap <silent> <D-3>      :tabn 3<CR>
noremap <silent> <D-4>      :tabn 4<CR>
noremap <silent> <D-5>      :tabn 5<CR>
noremap <silent> <D-6>      :tabn 6<CR>
noremap <silent> <D-7>      :tabn 7<CR>
noremap <silent> <D-8>      :tabn 8<CR>
noremap <silent> <D-9>      :tabn 9<CR>

" Replace and delete to black hole register and cut text with m (move)
nnoremap m d
vnoremap m d
nnoremap M D
vnoremap M D
vnoremap p "_dP
nnoremap c "_c
vnoremap c "_c
nnoremap C "_C
vnoremap C "_C
nnoremap d "_d
vnoremap d "_d
nnoremap D "_D
vnoremap D "_D
nnoremap x "_x
vnoremap x "_x
nnoremap X "_X
vnoremap X "_X

if has('nvim')
  tnoremap <ESC>     <C-\><C-n>
  tnoremap <C-h>     <C-\><C-n><C-w>h
  tnoremap <C-j>     <C-\><C-n><C-w>j
  tnoremap <C-k>     <C-\><C-n><C-w>k
  tnoremap <C-l>     <C-\><C-n><C-w>l
  tnoremap <C-x>     <C-\><C-n>:Sayonara!<CR>
  tnoremap <C-y>     <C-\><C-n>:Sayonara<CR>
  nnoremap <Leader>z :below 20sp term://$SHELL<CR>i
endif

" ------------------------------------------------------------------------------
" Autocommands
" ------------------------------------------------------------------------------
augroup AutocommandSettings
  " Restore cursor position
  autocmd BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif

  autocmd InsertEnter * set listchars-=trail:·
  autocmd InsertLeave * set listchars+=trail:·

  autocmd BufRead,BufNewFile *.mm setlocal filetype=objcpp

  if exists('+colorcolumn')
    autocmd FileType *           setlocal colorcolumn=
    autocmd FileType sh,zsh      setlocal colorcolumn=80
    autocmd FileType cpp         setlocal colorcolumn=100
    autocmd FileType python,ruby setlocal colorcolumn=120
    autocmd FileType gitcommit   setlocal colorcolumn=50,72
  endif

  autocmd FileType fzf tnoremap <ESC> <C-\><C-n>:Sayonara<CR>
  autocmd FileType c,cpp setlocal commentstring=//%s
augroup END

" ------------------------------------------------------------------------------
" Colorscheme
" ------------------------------------------------------------------------------
let g:one_allow_italics        = 1
let g:onedark_terminal_italics = 1

if !has('gui_running')
  let g:one_termcolors     = 16
  let g:onedark_termcolors = 16
endif

colorscheme onedark

if g:colors_name ==# 'onedark' || (g:colors_name ==# 'one' && &background ==# 'dark')
  let s:red         = ['#E06C75', '204']
  let s:yellow      = ['#E5C07B', '180']
  let s:green       = ['#98C379', '114']
  let s:blue        = ['#61AFEF', '39']
  let s:purple      = ['#C678DD', '170']
  let s:background  = ['#282C34', '235']
  let s:foreground  = ['#ABB2BF', '145']
  let s:shade_dark  = ['#2C323C', '236']
  let s:shade_light = ['#3E4452', '237']
endif

" ------------------------------------------------------------------------------
" Profile
" ----------------------------------------------------------------------------
function! s:profile()
    profile start /tmp/profile.log
    profile func *
    profile file *
endfunction

command! Profile call <SID>profile()

" ------------------------------------------------------------------------------
" Buffer Information
" ------------------------------------------------------------------------------
let s:buffer_name_map = {
      \ 'dirvish': 'Dirvish',
      \ 'gitcommit': 'Git Commit',
      \ 'nerdtree': 'NERD',
      \ 'niffler': 'Niffler',
      \ 'qf': 'Quickfix',
      \ 'startify': 'Startify',
      \ 'vim-plug': 'Plug'
      \ }

function! s:buffer_update()
  let b:is_special_buffer = has_key(s:buffer_name_map, &ft)
  let b:buffer_name = get(s:buffer_name_map, &ft, '')
endfunction

function! s:buffer_init()
  if exists('b:buffer_init')
    return
  endif
  let b:buffer_init = 1
  call s:buffer_update()
endfunction

autocmd BufWinEnter * call <SID>buffer_init()
autocmd FileType    * call <SID>buffer_update()

" ------------------------------------------------------------------------------
" Whitespace
" ------------------------------------------------------------------------------
exe "hi ExtraWhitespace gui=none cterm=none guifg=" . s:background[0] . " guibg=" . s:red[0] .
  \ " ctermfg=" . s:background[1] . " ctermbg=" . s:red[1]

" Use F5 to remove all trailing whitespace
nnoremap <silent> <F5> :let _s=@/ <Bar> :%s/\s\+$//e <Bar> :let @/=_s <Bar> :nohl <Bar> :unlet _s <CR>

function! s:match_whitespace(pattern)
  if !b:is_special_buffer && &buftype != 'nofile'
    exe 'match ExtraWhitespace ' . a:pattern
  endif
endfunction

autocmd InsertLeave,BufWinEnter * call <SID>match_whitespace('/\s\+$/')
autocmd InsertEnter             * call <SID>match_whitespace('/\s\+\%#\@<!$/')
autocmd BufWinLeave             * call <SID>match_whitespace("''")

" ------------------------------------------------------------------------------
" Plug
" ------------------------------------------------------------------------------
let g:plug_window = 'vertical rightbelow new'

" ------------------------------------------------------------------------------
" Gitgutter
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-gitgutter')
  let g:gitgutter_sign_removed = '-'
endif

" ------------------------------------------------------------------------------
" Dirvish
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-dirvish')
  function! s:dirvish_init()
    call fugitive#detect(@%)

    nnoremap <silent> <buffer> t :call dirvish#open('tabedit', 0)<CR>
    nnoremap <silent> <buffer> s :call dirvish#open('split', 0)<CR>
    nnoremap <silent> <buffer> v :call dirvish#open('vsplit', 0)<CR>
    nnoremap <buffer> + :edit %
    nnoremap <buffer> b :!mkdir %
    nnoremap <silent> <buffer> p :lcd %:p:h<CR>
    nnoremap <silent> <buffer> <C-R> :<C-u>Dirvish %<CR>

    " Sort folders to top and alphabetically
    sort ir /^.*[^\/]$/
  endfunction

  nnoremap <silent> <Leader><Leader> :Dirvish<CR>
  nnoremap <silent> <Leader>r        :Dirvish %<CR>

  autocmd FileType dirvish call <SID>dirvish_init()
endif

" ------------------------------------------------------------------------------
" Change to git root
" ------------------------------------------------------------------------------
function! s:cd_git_toplevel()
  execute 'lcd ' . expand("%:p:h")
  let l:toplevel = system('git rev-parse --show-toplevel')
  if !v:shell_error
    execute 'lcd ' . l:toplevel
  endif
endfunction

nnoremap <silent> <Leader>gt :call <SID>cd_git_toplevel()<CR>

" ------------------------------------------------------------------------------
" GitInfo using gitgutter and fugitive
" ------------------------------------------------------------------------------
function! s:get_git_hunk_status()
  if !exists('*GitGutterGetHunkSummary') || !get(g:, 'gitgutter_enabled', 0)
    return ''
  endif
  let hunks = GitGutterGetHunkSummary()
  let parts = [
      \ hunks[0] > 0 ? g:gitgutter_sign_added . hunks[0] : '',
      \ hunks[1] > 0 ? g:gitgutter_sign_modified . hunks[1] : '',
      \ hunks[2] > 0 ? g:gitgutter_sign_removed . hunks[2] : ''
      \ ]
  return join(filter(parts, 'len(v:val)'), ' ')
endfunction

function! s:get_git_branch()
  if !exists("*fugitive#head")
    return ''
  endif
  let branch = fugitive#head()
  return branch !=# '' ? s:symbol_vcs_branch . " " . branch : ''
endfunction

function! s:git_info()
  echo 'Git stats for file: ' . join(filter([s:get_git_hunk_status(), s:get_git_branch()], 'len(v:val)'), ' ')
endfunction

nnoremap <Leader>gi :call <SID>git_info()<CR>

" ------------------------------------------------------------------------------
" Bufferline
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-bufferline')
  let g:bufferline_echo                = 0
  let g:bufferline_active_buffer_left  = ''
  let g:bufferline_active_buffer_right = ''
  let g:bufferline_show_bufnr          = 0
  let g:bufferline_fname_mod           = ':~:.:s?^$?[No Name]?'
  let g:bufferline_pathshorten         = 1
endif

" ------------------------------------------------------------------------------
" Lightline
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'lightline.vim')
  let g:lightline                    = {}
  let g:lightline.colorscheme        = 'custom'
  let g:lightline.separator          = {'left': s:symbol_separator_left, 'right': s:symbol_separator_right}
  let g:lightline.subseparator       = {'left': s:symbol_subseparator_left, 'right': s:symbol_subseparator_right}
  let g:lightline.active             = {
        \ 'left': [['mode', 'paste'], ['readonly'], ['cwd'], ['filename']],
        \ 'right': [['percent', 'lineinfo'], ['whitespace', 'fileformat', 'fileencoding'], ['filetype']]
        \ }
  let g:lightline.tab                = {'active': ['tabnum'], 'inactive': ['tabnum']}
  let g:lightline.tabline            = {'left': [['tabs'], ['bufferline']], 'right': [['close']]}
  let g:lightline.component_expand   = {
        \ 'bufferline': 'LightLineBufferline',
        \ }
  let g:lightline.component_type     = {'bufferline': 'tabsel'}
  let g:lightline.component_function = {
        \ 'cwd': 'LightLineCWD',
        \ 'fileencoding': 'LightLineFileencoding',
        \ 'fileformat': 'LightLineFileformat',
        \ 'filename': 'LightLineFilename',
        \ 'filetype': 'LightLineFiletype',
        \ 'mode': 'LightLineMode',
        \ 'whitespace': 'LightLineWhitespace'
        \ }
  let g:lightline.component_function_visible_condition = {
        \ 'cwd': '1',
        \ 'fileencoding': '&fenc!=&enc',
        \ 'fileformat': '&fileformat!="unix"',
        \ 'filename': '!b:is_special_buffer',
        \ 'filetype': '!b:is_special_buffer',
        \ 'mode': '1',
        \ 'whitespace': '!b:is_special_buffer'
        \ }
  let g:lightline.mode_map           = {
        \ 'n': 'N', 'i': 'I', 'R': 'R', 'v': 'V', 'V': 'V', "\<C-v>": 'V',
        \ 'c': 'C', 's': 'S', 'S': 'S', "\<C-s>": 'S-BLOCK', 't': 'T'
        \ }

  let s:lightline_custom                 = {'normal': {}, 'inactive': {}, 'insert': {}, 'replace': {}, 'visual': {}, 'tabline': {}}
  let s:lightline_custom.normal.left     = [[s:background, s:green], [s:foreground, s:shade_light], [s:foreground, s:shade_dark]]
  let s:lightline_custom.normal.right    = deepcopy(s:lightline_custom.normal.left)
  let s:lightline_custom.normal.middle   = [[s:green, s:background]]
  let s:lightline_custom.inactive.left   = [[s:foreground, s:shade_dark]]
  let s:lightline_custom.inactive.right  = deepcopy(s:lightline_custom.inactive.left)
  let s:lightline_custom.inactive.middle = deepcopy(s:lightline_custom.inactive.left)
  let s:lightline_custom.insert.left     = [[s:background, s:blue], [s:foreground, s:shade_light], [s:foreground, s:shade_dark]]
  let s:lightline_custom.insert.right    = deepcopy(s:lightline_custom.insert.left)
  let s:lightline_custom.insert.middle   = [[s:blue, s:background]]
  let s:lightline_custom.replace.left    = [[s:background, s:red], [s:foreground, s:shade_light], [s:foreground, s:shade_dark]]
  let s:lightline_custom.replace.right   = deepcopy(s:lightline_custom.replace.left)
  let s:lightline_custom.replace.middle  = [[s:red, s:background]]
  let s:lightline_custom.visual.left     = [[s:background, s:purple], [s:foreground, s:shade_light], [s:foreground, s:shade_dark]]
  let s:lightline_custom.visual.right    = deepcopy(s:lightline_custom.visual.left)
  let s:lightline_custom.visual.middle   = [[s:purple, s:background]]
  let s:lightline_custom.tabline.left    = [[s:foreground, s:shade_light],  [s:foreground, s:shade_dark]]
  let s:lightline_custom.tabline.right   = [[s:background, s:purple]]
  let s:lightline_custom.tabline.middle  = [[s:green, s:background]]
  let s:lightline_custom.tabline.tabsel  = [[s:background, s:green]]
  let s:lightline_custom.normal.error    = [[s:background, s:red]]
  let s:lightline_custom.normal.warning  = [[s:background, s:yellow]]

  let g:lightline#colorscheme#custom#palette = lightline#colorscheme#flatten(s:lightline_custom)

  function! s:strip(input)
    return substitute(a:input, '^\s*\(.\{-}\)\s*$', '\1', '')
  endfunction

  function! LightLineBufferline()
    call bufferline#refresh_status()
    let buffers = [
          \ g:bufferline_status_info.before,
          \ g:bufferline_status_info.current,
          \ g:bufferline_status_info.after
          \ ]
    call map(buffers, 's:strip(v:val)')
    return buffers
  endfunction

  function! LightLineCWD()
    return winwidth(0) < 80 ? '' : getcwd()
  endfunction

  function! LightLineFilename()
    return b:is_special_buffer ? '' :
          \ (@% == '' ? '[No Name]' : expand('%:.')) .
          \ (&modified ? '+' : &modifiable ? '' : '-')
  endfunction

  function! LightLineFiletype()
    return b:is_special_buffer ? '' : &ft == '' ? '--' : &ft
  endfunction

  function! LightLineWhitespace()
    return b:is_special_buffer ? '' : &shiftwidth . (&expandtab ? "S" : "T")
  endfunction

  function! LightLineFileformat()
    return &fileformat == 'unix' ? '' :
          \ &fileformat == 'dos' ? 'CRLF' :
          \ &fileformat == 'mac' ? 'CR' : '??'
  endfunction

  function! LightLineFileencoding()
    return &fenc == &enc ? '' : &fenc
  endfunction

  function! LightLineMode()
      return b:is_special_buffer ? b:buffer_name : lightline#mode()
  endfunction
endif

" ------------------------------------------------------------------------------
" NERDTree
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'nerdtree')
  let g:NERDTreeChDirMode           = 2 " Change cwd when root changes
  let g:NERDTreeDirArrowCollapsible = '-'
  let g:NERDTreeDirArrowExpandable  = '+'
  let g:NERDTreeIgnore              = ['\.DS_Store$']
  let g:NERDTreeMinimalUI           = 1 " Reduce some clutter
  let g:NERDTreeMouseMode           = 2 " Single click opens any node
  let g:NERDTreeShowBookmarks       = 1 " Show bookmarks
  let g:NERDTreeShowHidden          = 1 " Show hidden files

  " Show file tree
  map <Leader><Leader> :NERDTreeToggle<CR>
  " Reveal file in file tree
  map <Leader>r :NERDTreeFind<CR>

  " Hide whitespace symbols in nerdtree
  autocmd FileType nerdtree setlocal nolist
endif

" ------------------------------------------------------------------------------
" Sneak
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-sneak')
  let g:sneak#streak = 1

  hi link SneakPluginTarget IncSearch
  hi link SneakStreakTarget IncSearch
  hi link SneakPluginScope  Comment
  hi link SneakStreakMask   Comment
endif

" ------------------------------------------------------------------------------
" Syntastic
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'syntastic')
  let g:syntastic_always_populate_loc_list = 1
  let g:syntastic_auto_jump                = 1
  let g:syntastic_auto_loc_list            = 1
  let g:syntastic_enable_ballons           = has('ballon_eval')
  let g:syntastic_error_symbol             = '☒'
  let g:syntastic_warning_symbol           = '⚠'
  let g:syntastic_loc_list_height          = 3
  let g:syntastic_check_on_wq              = 0
  let g:syntastic_cpp_compiler_options     = '-std=c++14 -stdlib=libc++'
  let g:syntastic_cpp_checkers             = [] " or ['clang_tidy']
  let g:syntastic_cpp_clang_tidy_post_args = '-p build/compile_commands.json'

  nnoremap <F4> :SyntasticCheck<CR>
endif

" ------------------------------------------------------------------------------
" Ycm
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'YouCompleteMe')
  let g:ycm_autoclose_preview_window_after_completion = 1
  let g:ycm_key_list_select_completion                = ['<TAB>', '<Down>', '<Enter>']
  let g:ycm_global_ycm_extra_conf                     = '~/.vim/ycm_config.py'
  let g:ycm_filetype_whitelist                        = {'python': 1, 'cpp': 1}
  " let g:ycm_show_diagnostics_ui = 0 " Enable this line to have clang-tidy checks using syntastic

  nnoremap jd   :YcmCompleter GoToDefinition<CR>
  nnoremap jj   :YcmCompleter GoToDefinitionElseDeclaration<CR>
  nnoremap jc   :YcmCompleter GoToDeclaration<CR>
  nnoremap jk   :YcmCompleter GoToInclude<CR>
  nnoremap jp   :YcmDiags<CR>
  nnoremap <F3> :YcmForceCompileAndDiagnostics<CR>
endif

" ------------------------------------------------------------------------------
" Fugitive
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-fugitive')
  nnoremap <Space>ga :Gcommit -v -q --amend<CR>
  nnoremap <Space>gb :Gblame<CR>
  nnoremap <Space>gc :Gcommit -v -q<CR>
  nnoremap <Space>gd :Gdiff<CR>
  nnoremap <Space>gg :Ggrep<Space>
  nnoremap <Space>gl :silent! Glog<CR>:bot copen<CR>
  nnoremap <Space>gm :Gmove<Space>
  nnoremap <Space>gp :Dispatch! git push<CR>
  nnoremap <Space>gr :Dispatch! git pull --rebase<CR>
  nnoremap <Space>gs :Gstatus<CR>
endif

" ------------------------------------------------------------------------------
" fzf
" ------------------------------------------------------------------------------
if has('nvim') && has_key(g:plugs, 'fzf.vim')
  function! s:FZFGrep(bang, args)
    let l:grepargs = empty(a:args) ? expand("<cword>") : a:args . join(a:000, ' ')
    call fzf#vim#grep('rg --color=always --no-heading --line-number --column --smart-case --hidden --glob "!.git" --glob "!.svn" '.shellescape(l:grepargs), 1, a:bang)
  endfunction

  let $FZF_DEFAULT_COMMAND = 'rg --files --hidden --glob "!.git" --glob "!.svn" ""'
  let $FZF_DEFAULT_OPTS .= ' --inline-info'

  nnoremap <C-p> :FZF<CR>
  nnoremap <C-o> :Buffers<CR>
  command! -bang -nargs=* FZG call s:FZFGrep(<bang>0, <q-args>)
endif

" ------------------------------------------------------------------------------
" CtrP
" ------------------------------------------------------------------------------
if !has('nvim') && has_key(g:plugs, 'ctrlp.vim')
  let g:ctrlp_by_filename  = 1
  let g:ctrlp_user_command = 'rg --files --hidden --glob "!.git" --glob "!.svn" "" %s'

  if has_key(g:plugs, 'ctrlp-cmatcher')
    let g:ctrlp_match_func = {'match' : 'matcher#cmatch'}
  endif

  nnoremap <C-p> :CtrlP<CR>
  nnoremap <C-o> :CtrlPBuffer<CR>
endif

" ------------------------------------------------------------------------------
" Niffler
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-niffler')
  let g:niffler_user_command = 'rg --files --hidden --glob "!.git" --glob "!.svn" %s'

  nnoremap <C-p> :Niffler -vcs<CR>
  nnoremap <C-o> :NifflerBuffer<CR>

  " Hide niffler buffer in the bufferlist
  autocmd FileType niffler setlocal nobuflisted
endif
" ------------------------------------------------------------------------------
" Easy-Align
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-easy-align')
  " Start interactive EasyAlign in visual mode (e.g. vipga)
  xmap ga <Plug>(LiveEasyAlign)

  " Start interactive EasyAlign for a motion/text object (e.g. gaip)
  nmap ga <Plug>(LiveEasyAlign)
endif

" ------------------------------------------------------------------------------
" Ack.vim
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'ack.vim')
  let g:ackprg         = 'rg --no-heading --line-number --column'
  let g:ackhighlight     = 1
  let g:ack_use_dispatch = 1

  nnoremap <Leader>vv :Ack <cword><CR>
  nnoremap <Leader>ff :Ack<Space>
endif

" ------------------------------------------------------------------------------
" Grepper
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-grepper')
  let g:grepper = {
        \ 'highlight': 1,
        \ 'tools': ['rg', 'git', 'grep'],
        \ 'rg': {
        \   'grepprg': 'rg --no-heading --line-number --column --hidden --glob "!.git" --glob "!.svn" $* .',
        \   'grepformat': '%f:%l:%c:%m'
        \ }}

  nnoremap <Leader>vv :Grepper -tool rg -cword -noprompt<CR>
  nnoremap <Leader>ff :Grepper -tool rg<CR>
endif

" ------------------------------------------------------------------------------
" Startify
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-startify')
  let g:startify_list_order = [
        \ ['Bookmarks'],  'bookmarks',
        \ ['MRU'],        'files',
        \ ['MRU in CWD [' . getcwd() . ']'], 'dir',
        \ ['Sessions'],   'sessions',
        \ ['Commands'],   'commands']
  let g:startify_bookmarks  = [
        \ {'bc': '~/.dotfiles/vim/vimrc'},
        \ {'bz': '~/.dotfiles/zshrc'},
        \ {'bl': '~/.dotfiles'},
        \ {'bd': '/Volumes/DATA/repos/development'}]
  let g:startify_use_env    = 1
  let g:startify_skiplist   = ['vim/plugged', '.git', resolve($VIMRUNTIME)]

  nnoremap <silent> <Leader>s :Startify<CR>
endif

" ------------------------------------------------------------------------------
" clang-format
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-clang-format')
  let g:clang_format#detect_style_file = 1

  augroup ClangFormatSettings
    autocmd FileType c,cpp,objc,objcpp nnoremap <buffer><Leader>cf :<C-u>ClangFormat<CR>
    autocmd FileType c,cpp,objc,objcpp vnoremap <buffer><Leader>cf :ClangFormat<CR>
  augroup END
endif

" ------------------------------------------------------------------------------
" vim.cpp
" ------------------------------------------------------------------------------
if has_key(g:plugs, 'vim-cpp-enhanced-highlight')
  let c_no_curly_error                      = 1 " Do not show curly braces error in cpp files
  let g:cpp_class_scope_highlight           = 1 " Highlight class scope
  let g:cpp_experimental_template_highlight = 1 " Highlight template functions
endif

" ------------------------------------------------------------------------------
" Local config
" ------------------------------------------------------------------------------
let s:local_vimrc = fnamemodify(resolve(expand('<sfile>')), ':p:h').'/vimrc.local'
if filereadable(s:local_vimrc)
  execute 'source' s:local_vimrc
endif
